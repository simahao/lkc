# 信号

## 信号系统的主要系统调用

在操作系统中，信号系统是处理异步事件的重要机制。以下是信号系统的主要系统调用：

1. **`sys_rt_sigaction`**
   - 为一个信号设置用户态处理程序。

2. **`sys_rt_sigprocmask`**
   - 设置当前线程的信号阻塞掩码。

3. **`sys_rt_sigreturn`**
   - 线程在用户态完成信号处理后，通过此系统调回到内核态并恢复原先的执行流。

4. **`sys_kill`**
   - 向指定进程组中的所有线程发送特定信号。

5. **`sys_tkill`**
   - 向特定线程发送信号。

## 信号系统的数据结构设计

信号系统的数据结构设计关键在于线程的信号处理。以下是线程中与信号处理相关的主要字段：

```c
int sig_pending_cnt;       // 待处理信号的数量
struct sighand *sig;       // 信号处理结构体
sigset_t blocked;          // 当前线程阻塞的信号集合
struct sigpending pending; // 待处理信号队列（私有）
sig_t sig_ing;             // 当前处理的信号
```

信号系统的数据结构设计图示：

![信号系统数据结构](signal.assets/image-20230819154533735.png)

## 信号系统设计的难点

信号系统设计中的一个主要难点是执行流的切换问题，即如何确保线程在接收到信号后能够及时处理信号，执行用户态处理程序，并最终恢复正常的执行流。

处理信号的流程图：

![信号处理流程](signal.assets/image-20230819154648058.png)

在我们的设计中，信号处理是在`usertrapret`中进行的。当线程返回到用户态时，会检查是否有待处理的信号。如果发现`pending_list`非空，将从头开始处理信号，处理完毕后从`pending_list`中移除。

### 注意事项

1. 将`trapframe`、阻塞掩码和当前处理的信号编号组合在一起压入用户栈。
2. 通过共享SIGRETURN页面，实现处理程序执行完毕后正常触发`sig_return`系统调用。
3. 压栈操作需注意字节对齐。
4. 确保`a2`寄存器被正确赋值。

### `SIGRETURN`的实现

```assembly
.section sigret_sec
.global __user_rt_sigreturn
__user_rt_sigreturn:
    li a7, 139 # SYS_rt_sigreturn
    ecall
```

## 关于`pthread_cancel`的一些问题

`pthread_cancel`是用于请求取消一个线程的机制。以下是处理`pthread_cancel`时的几种执行流：

1. 第一种情况，线程直接进入`pthread_exit`然后退出。
2. 第二种情况，在`sig_return`时需要设置`epc`，改变用户态执行流。
3. 第三个情况，防止多次触发`SIGCANCEL`信号，确保在处理一个信号时不会多次重入，避免死循环。

## 总结

信号系统是操作系统内核中处理异步事件的关键部分。它允许内核和用户态程序以一种预定的方式响应外部事件。通过精心设计的数据结构和系统调用，我们能够实现一个健壮、高效的信号系统。我们的信号系统支持多线程环境下的信号处理，并通过一系列优化确保了执行流的正确切换和信号的及时响应。