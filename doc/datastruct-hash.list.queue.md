# 数据结构

在操作系统内核开发中，数据结构是实现各种功能的基础。以下是内核中常用的几种数据结构的总结。

## 哈希表 (Hash)

### 为什么内核中需要哈希表？

内核中的许多操作需要快速查找、插入和删除数据。传统的顺序扫描方法在处理大数据集时效率较低。哈希表通过哈希函数将键映射到一个固定索引位置，从而实现快速的数据访问，其平均时间复杂度为 O(1)。

### 实现哈希表需要的数据结构和接口

哈希表的实现涉及到以下关键数据结构和接口：

- **哈希表类型** (`enum hash_type`): 定义了不同的哈希表类型，如进程ID映射、线程ID映射等。
- **哈希节点** (`struct hash_node`): 存储键值对，并通过链表连接具有相同哈希值的节点。
- **哈希表入口** (`struct hash_entry`): 作为哈希表的索引入口。
- **哈希表** (`struct hash_table`): 包含哈希表的元数据，如锁、类型、大小和入口数组。

哈希表的接口包括：

- `hash_get_entry`: 查找表项。
- `hash_lookup`: 查找哈希表。
- `hash_insert`: 插入哈希节点。
- `hash_delete`: 删除键。
- `hash_destroy`: 销毁哈希表。
- `hash_str`: 计算字符串的哈希值。
- `hash_val`: 根据哈希表类型获取哈希节点的键。
- `hash_bool`: 判断哈希节点的键。
- `hash_assign`: 为哈希节点赋值。
- `hash_table_entry_init`: 初始化哈希表入口。

## 链表 (List)

### 如何使用 list.h

内核中的链表操作通常遵循以下步骤：

1. 定义 `struct list_head` 作为链表节点。
2. 使用 `container_of` 宏获取包含 `list_head` 的结构体指针。
3. 通过 `INIT_LIST_HEAD` 初始化链表头。
4. 使用提供的接口进行链表操作，如添加、删除、遍历等。

### 内核中使用链表的例子

- **队列** (`struct Queue`): 实现了锁、列表和队列类型。
- **LRU 缓存**: 使用链表维护缓存条目。
- **哈希表**: 使用链表解决哈希冲突。
- **伙伴系统** (`struct page` 和 `struct free_list`): 使用链表管理内存块。
- **虚拟内存区域** (`struct vma`): 使用链表维护内存区域。
- **进程和线程管理**: 使用链表维护进程和线程的关系及状态。

### 注意点

- 对于全局变量，使用锁进行保护。
- 遍历时使用带 `safe` 后缀的接口。
- 定义数据结构时，包含单独的链表头入口。

## 队列 (Queue)

### 为什么需要队列？

队列提供了一种先进先出（FIFO）的数据结构，用于优化进程调度和同步机制（如条件变量、信号量、futex）的实现。队列可以减少不必要的查找和提高效率。

### 实现队列需要的数据结构和接口

队列的实现依赖于 `Queue` 结构体，它包含：

- 锁 (`struct spinlock`): 保护队列操作。
- 链表 (`struct list_head`): 存储队列中的元素。
- 名称和类型 (`char name[]`, `enum queue_type type`): 标识队列。

队列的接口包括：

- `Queue_init`: 初始化队列。
- `Queue_isempty`: 判断队列是否为空。
- `queue_entry`: 获取节点的列表入口。
- `queue_first_node`: 获取队列的第一个节点。
- `Queue_push_back`: 向队列尾部添加元素。
- `Queue_remove`: 从队列移除元素。
- `Queue_pop`: 从队列弹出元素。

### 内核中使用队列的场景

- **条件变量** (`struct cond`): 使用队列管理等待的线程。
- **futex**: 使用队列管理等待的线程。
- **信号量** (`struct semaphore`): 间接使用队列。
- **进程和线程调度**: 使用队列管理不同状态的进程和线程。

### 补充

使用全局队列指针数组可以方便地进行状态切换，如进程状态和线程状态队列。

通过这些数据结构，操作系统内核能够高效地管理资源、优化调度算法，并实现复杂的同步机制。